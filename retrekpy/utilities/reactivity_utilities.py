""" The ``retrekpy.utilities`` package ``reactivity_utilities`` module. """

from typing import List, Optional, Tuple, Union

from rdchiral.main import rdchiralReactants, rdchiralReaction, rdchiralRun

from rdkit.Chem import Mol
from rdkit.Chem.rdChemReactions import ReactionFromSmarts, SanitizeRxn

from .format_conversion_utilities import FormatConversionUtilities


class ReactivityUtilities:
    """ The class for the application of reaction templates in the forward and backward direction. """

    @staticmethod
    def __remove_duplicate_molecules(
            mol_combinations: List[Tuple[Mol]]
    ) -> List[Tuple[Optional[str], ...]]:
        """
        Remove the duplicate molecule combination tuples from a given list.

        Input:
            mol_combinations (List[Tuple[Mol]]): The list of molecule combination tuples.

        Output:
            (List[Tuple[Optional[str], ...]]): The same collection of molecule combination tuples without duplicates,
                and in canonical SMILES tuple format.
        """

        correct_mol_combinations = list()

        for mol_combination in mol_combinations:
            mol_combination_tuple = tuple([
                FormatConversionUtilities.mol_to_canonical_smiles(mol)
                for mol in mol_combination
            ])

            if None in mol_combination_tuple:
                continue

            else:
                correct_mol_combinations.append(mol_combination_tuple)

        return list(set(correct_mol_combinations))

    @staticmethod
    def __remove_duplicate_molecules_rdchiral(
            mol_combinations: List[Tuple[str]]
    ) -> List[Tuple[Optional[str], ...]]:
        """
        Remove the duplicate molecule combination tuples from a given list.

        Input:
            mol_combinations (List[Tuple[Mol]]): The list of molecule combination tuples.

        Output:
            (List[Tuple[Optional[str], ...]]): The same collection of molecule combination tuples without duplicates,
                and in canonical SMILES tuple format.
        """

        correct_mol_combinations = list()

        for mol_combination in mol_combinations:
            mol_combination_tuple = tuple([
                FormatConversionUtilities.smiles_to_canonical_smiles(smiles)
                for smiles in mol_combination
            ])

            if None in mol_combination_tuple:
                continue

            else:
                correct_mol_combinations.append(mol_combination_tuple)

        return list(set(correct_mol_combinations))

    @staticmethod
    def __check_suggested_mol_validity(
            mol_combinations: List[Tuple[Optional[str], ...]]
    ) -> List[Tuple[Optional[Mol], ...]]:
        """
        Check the chemical validity of the molecules in a list of combination tuples.

        Input:
            mol_combinations (List[Tuple[Optional[str], ...]]): The list of molecule SMILES string combination tuples.

        Output:
            (List[Tuple[Optional[Mol], ...]]): The same collection of molecule combination tuples containing only valid
                molecules in RDKit Mol object tuple format.
        """

        correct_mol_combinations = []

        for mol_combination in mol_combinations:
            mol_combination_tuple = tuple([
                FormatConversionUtilities.smiles_to_mol(mol_smiles)
                for mol_smiles in mol_combination
            ])

            if None in mol_combination_tuple:
                continue

            else:
                correct_mol_combinations.append(mol_combination_tuple)

        return correct_mol_combinations

    @staticmethod
    def forward_apply(
            reactant_mols: Union[str, Mol, List[str], List[Mol], Tuple[str, ...], Tuple[Mol, ...]],
            rxn_template: str,
            return_type: str = "mol"
    ) -> Union[List[Tuple[Optional[str], ...]], List[Tuple[Optional[Mol], ...]]]:
        """
        Apply a specified reaction rule template on a single or a group of reactant molecules.

        Input:
            reactant_mols (Union[str, Mol, List[str], List[Mol], Tuple[str, ...], Tuple[Mol, ...]]): The collection of
                reactant SMILES strings or RDKit Mol objects.
            rxn_template (str): The reaction template based on which the reactants are determined.
            return_type (str): The format in which the results are returned. Can be 'str' for SMILES strings, or 'mol'
                for RDKit Mol objects.

        Output:
            (Union[List[Tuple[Optional[str], ...]], List[Tuple[Optional[Mol], ...]]]): The list of potential product
                combination tuples generated by PyReactor.
        """

        if rxn_template == "":
            raise Exception("The input reaction template is empty.")

        if isinstance(reactant_mols, str) or isinstance(reactant_mols, Mol):
            if isinstance(reactant_mols, str):
                reactant_mols = [FormatConversionUtilities.smiles_to_mol(reactant_mols)]

            else:
                reactant_mols = [reactant_mols]

        else:
            if len(reactant_mols) == 0:
                raise Exception("The input collection of reactants is empty.")

            if isinstance(reactant_mols[0], str):
                reactant_mols = [FormatConversionUtilities.smiles_to_mol(mol) for mol in reactant_mols]

        if None in reactant_mols:
            raise Exception(
                "Not all reactants could be successfully converted to RDKit Mol objects. "
                "Please check the validity of the given reactant SMILES strings."
            )

        else:
            if len(rxn_template.split(">")[0].split(".")) != len(reactant_mols):
                raise Exception(
                    "The number of given reactants does not match the number of reactants in the template."
                )

        # Try to create and sanitize the RDKit ChemicalReaction object from the given reaction template.
        try:
            rxn = ReactionFromSmarts(rxn_template)

            SanitizeRxn(rxn)

            # Remove any potential duplicate suggestions.
            products_suggestions_str = ReactivityUtilities.__remove_duplicate_molecules(rxn.RunReactants(reactant_mols))

            if return_type == "str":
                return products_suggestions_str

            else:
                # Convert the SMILES strings into RDKit Mol objects and check their chemical validity.
                return ReactivityUtilities.__check_suggested_mol_validity(products_suggestions_str)

        except Exception as exception:
            raise Exception(
                "Exception occurred during the construction of the ChemicalReaction object from the reaction SMARTS "
                "'{}'. Please make sure that the reaction template is correct. "
                "Detailed exception message: \n{}".format(rxn_template, exception)
            )

    @staticmethod
    def reverse_apply_rdchiral(
            product_mols: Union[str, Mol, List[str], List[Mol], Tuple[str, ...], Tuple[Mol, ...]],
            rxn_template: str,
            max_products: int = 10,
            return_type: str = "mol"
    ) -> Union[List[Tuple[Optional[str], ...]], List[Tuple[Optional[Mol], ...]]]:
        """
        Apply a specified reaction rule template backwards on a single or group of product molecules using RDChiral.

        Input:
            product_mols (Union[str, Mol, List[str], List[Mol], Tuple[str, ...], Tuple[Mol, ...]]): The collection of
                product SMILES strings or RDKit Mol objects.
            rxn_template (str): The reaction template based on which the products are determined.
            return_type (str): The format in which the results are returned. Can be 'str' for SMILES strings, or 'mol'
                for RDKit Mol objects.

        Output:
            (Union[List[Tuple[Optional[str], ...]], List[Tuple[Optional[Mol], ...]]]): The list of potential reactant
                combination tuples generated by PyReactor.
        """

        if rxn_template == "":
            raise Exception("The input reaction template is empty.")

        if max_products <= 0:
            raise Exception("The number of generated products needs to be a positive number larger than 0.")

        if isinstance(product_mols, str) or isinstance(product_mols, Mol):
            if isinstance(product_mols, str):
                product_mols = [product_mols]

            else:
                product_mols = [FormatConversionUtilities.mol_to_canonical_smiles(product_mols)]

        else:
            if len(product_mols) == 0:
                raise Exception("The input collection of products is empty.")

            if isinstance(product_mols[0], Mol):
                product_mols = [FormatConversionUtilities.mol_to_canonical_smiles(mol) for mol in product_mols]

        if None in product_mols:
            raise Exception(
                "Not all products could be successfully converted to RDKit Mol objects. "
                "Please check the validity of the given product SMILES strings."
            )

        else:
            if len(rxn_template.split(">")[2].split(" ")[0].split(".")) != len(product_mols):
                raise Exception("The number of given products does not match the number of products in the template.")

        try:
            # Split the reaction rule template SMARTS string into reactants and products substrings.
            reactants_substr, _, products_substr = rxn_template.split(">")

            # Generate a reverse reaction SMARTS string.
            rxn_template = ">>".join([products_substr, reactants_substr])

            # Run the textual RDChiral suggestion generator.
            reactants_suggestions = rdchiralRun(
                rdchiralReaction(rxn_template),
                rdchiralReactants(".".join(product_mols))
            )

            reactants_suggestions = [tuple(rs.split(".")) for rs in reactants_suggestions]

            # Remove any potential duplicate suggestions.
            reactants_suggestions_str = ReactivityUtilities.__remove_duplicate_molecules_rdchiral(reactants_suggestions)

            # Sort results to allow reproducibility.
            reactants_suggestions_str.sort()

            if return_type == "str":
                return reactants_suggestions_str[0:max_products]

            else:
                # Convert the SMILES strings into RDKit Mol objects and check their chemical validity.
                return ReactivityUtilities.__check_suggested_mol_validity(reactants_suggestions_str)[0:max_products]

        except Exception as exception:
            raise Exception(
                "Exception occurred during the construction of the RDChiral ChemicalReaction object from the reaction "
                "SMARTS '{}'. Please make sure that the reaction template is correct. "
                "Detailed exception message: \n{}".format(rxn_template, exception)
            )

    @staticmethod
    def reverse_apply(
            product_mols: Union[str, Mol, List[str], List[Mol], Tuple[str, ...], Tuple[Mol, ...]],
            rxn_template: str,
            max_products: int = 10,
            return_type: str = "mol"
    ) -> Union[List[Tuple[Optional[str], ...]], List[Tuple[Optional[Mol], ...]]]:
        """
        Apply a specified reaction rule template backwards on a single or group of product molecules.

        Input:
            product_mols (Union[str, Mol, List[str], List[Mol], Tuple[str, ...], Tuple[Mol, ...]]): The collection of
                product SMILES strings or RDKit Mol objects.
            rxn_template (str): The reaction template based on which the products are determined.
            return_type (str): The format in which the results are returned. Can be 'str' for SMILES strings, or 'mol'
            for RDKit Mol objects.

        Output:
            (Union[List[Tuple[Optional[str], ...]], List[Tuple[Optional[Mol], ...]]]): The list of potential reactant
                combination tuples generated by PyReactor.
        """

        if rxn_template == "":
            raise Exception("The input reaction template is empty.")

        if max_products <= 0:
            raise Exception("The number of generated products needs to be a positive number larger than 0.")

        if isinstance(product_mols, str) or isinstance(product_mols, Mol):
            if isinstance(product_mols, str):
                product_mols = [FormatConversionUtilities.smiles_to_mol(product_mols)]

            else:
                product_mols = [product_mols]

        else:
            if len(product_mols) == 0:
                raise Exception("The input collection of products is empty.")

            if isinstance(product_mols[0], str):
                product_mols = [FormatConversionUtilities.smiles_to_mol(mol) for mol in product_mols]

        if None in product_mols:
            raise Exception(
                "Not all products could be successfully converted to RDKit Mol objects. "
                "Please check the validity of the given product SMILES strings."
            )

        else:
            if len(rxn_template.split(">")[2].split(" ")[0].split(".")) != len(product_mols):
                raise Exception("The number of given products does not match the number of products in the template.")

        try:
            # Split the reaction rule template SMARTS string into reactants and products substrings.
            reactants_substr, _, products_substr = rxn_template.split(">")

            # Generate a reverse reaction rule template SMARTS string.
            rxn_template = ">>".join([products_substr, reactants_substr])

            # Try to create and sanitize the RDKit ChemicalReaction object.
            rxn = ReactionFromSmarts(rxn_template)

            SanitizeRxn(rxn)

            # Remove any potential duplicate suggestions.
            reactants_suggestions_str = ReactivityUtilities.__remove_duplicate_molecules(
                rxn.RunReactants(product_mols, maxProducts=max_products)
            )

            # Sort results to allow reproducibility.
            reactants_suggestions_str.sort()

            if return_type == "str":
                return reactants_suggestions_str

            else:
                # Convert the SMILES strings into RDKit Mol objects and check their chemical validity.
                return ReactivityUtilities.__check_suggested_mol_validity(reactants_suggestions_str)

        except Exception as exception:
            raise Exception(
                "Exception occurred during the construction of the ChemicalReaction object from the reaction SMARTS "
                "'{}'. Please make sure that the reaction template is correct. "
                "Detailed exception message: \n{}".format(rxn_template, exception)
            )
